import boto3
import pandas as pd
import time
import io # For reading CSV from S3 if needed directly

# --- Configuration ---
ATHENA_DATABASE = 'your_athena_database' # Your main Athena database
S3_OUTPUT_LOCATION = 's3://your-athena-query-results-bucket/path/' # For Athena query results
S3_STAGING_DIR = 's3://your-data-bucket/staging/' # For intermediate CSVs if needed
ATHENA_WORKGROUP = 'primary' # Or your specific workgroup

# Macro variable equivalents
archive_list_py = ['BO_EXAMPLE_ARCHIVED1', 'BO_EXAMPLE_ARCHIVED2'] # Example
per_py = '202306' # Example YYYYMM, adjust as needed

# Initialize Athena client
athena_client = boto3.client('athena')
s3_client = boto3.client('s3')

# --- Helper Function to Run Athena Queries and Get Results ---
def run_athena_query(query_string, database=ATHENA_DATABASE, s3_output=S3_OUTPUT_LOCATION):
    """Executes an Athena query and waits for completion."""
    print(f"Executing Query: \n{query_string[:500]}...") # Print start of query
    response = athena_client.start_query_execution(
        QueryString=query_string,
        QueryExecutionContext={'Database': database},
        ResultConfiguration={'OutputLocation': s3_output},
        WorkGroup=ATHENA_WORKGROUP
    )
    query_execution_id = response['QueryExecutionId']
    
    while True:
        stats = athena_client.get_query_execution(QueryExecutionId=query_execution_id)
        status = stats['QueryExecution']['Status']['State']
        if status in ['SUCCEEDED', 'FAILED', 'CANCELLED']:
            break
        time.sleep(5) # Poll every 5 seconds

    if status != 'SUCCEEDED':
        error_message = stats['QueryExecution']['Status'].get('StateChangeReason', 'Unknown error')
        raise Exception(f"Athena query {query_execution_id} failed: {status} - {error_message}")
    
    print(f"Query {query_execution_id} Succeeded.")
    return query_execution_id

def get_query_results_as_df(query_execution_id):
    """Fetches query results into a Pandas DataFrame."""
    results_paginator = athena_client.get_paginator('get_query_results')
    results_iter = results_paginator.paginate(
        QueryExecutionId=query_execution_id,
        PaginationConfig={'PageSize': 1000}
    )
    
    rows = []
    column_names = None
    for results_page in results_iter:
        if column_names is None and results_page.get('ResultSet', {}).get('ResultSetMetadata'):
            column_names = [col['Name'] for col in results_page['ResultSet']['ResultSetMetadata']['ColumnInfo']]
        
        for row in results_page['ResultSet']['Rows']:
            rows.append([field.get('VarCharValue') for field in row['Data']])
            
    if not rows:
        return pd.DataFrame()

    # First row of actual data might be column headers if not handled above, or data starts from index 1
    # If column_names were correctly fetched from metadata, data starts from first row.
    # If first row in `rows` is identical to `column_names`, slice it off.
    if rows and column_names and rows[0] == column_names:
        df = pd.DataFrame(rows[1:], columns=column_names)
    else:
        df = pd.DataFrame(rows, columns=column_names) # This might need adjustment
    return df

# --- Main Script Logic ---

def phase1_initial_data_staging(archive_list, per_cutoff):
    print("\n--- Phase 1: Initial Data Staging ---")

    # Helper to format list for SQL IN clause
    def format_for_sql_in(py_list):
        if not py_list: return "('')" # Handle empty list to avoid SQL syntax error
        return ', '.join([f"'{item}'" for item in py_list])

    archive_list_sql = format_for_sql_in(archive_list)

    # 1. Create cld_master
    # Opt_in hardcoding needs to be translated to CASE WHEN
    # Example for a few campaign_ids, extend this list
    opt_in_case_statements = """
        CASE
            WHEN compress(Campaign_id) = 'B031836' THEN 'N'
            WHEN compress(Campaign_id) = 'B038887' THEN 'Y'
            WHEN compress(Campaign_id) = 'B035118' THEN 'Y'
            -- ... add all other campaign_id conditions from SAS code ...
            WHEN compress(Campaign_id) = 'B052180' THEN 'N'
            ELSE NULL -- Or some default
        END AS Opt_in
    """
    query_cld_master = f"""
    CREATE TABLE IF NOT EXISTS cld_master_py AS
    SELECT
        *,
        {opt_in_case_statements}
    FROM cld_contact_log_master -- Assuming this is your Athena table
    WHERE Campaign_id NOT IN ({archive_list_sql});
    """
    run_athena_query(query_cld_master)

    # 2. Collect Distinct Campaign IDs (for opt_in filtering)
    query_get_campaign_ids = """
    SELECT DISTINCT Campaign_id FROM cld_contact_log_master;
    """
    # In SAS this became a macro var. Here, we'll fetch and use in the next query.
    # For very long lists, consider a temporary table and JOIN.
    exec_id = run_athena_query(query_get_campaign_ids)
    df_campaign_ids = get_query_results_as_df(exec_id)
    campaign_id_list_sql = format_for_sql_in(df_campaign_ids['Campaign_id'].tolist())
    
    print(f"Collected Campaign IDs for IN clause: {campaign_id_list_sql[:200]}...")


    # 3. Process Opt-in Account Data
    # Assuming accept_dt is a date/timestamp. yymmn6. format means 'YYYYMM'
    # MMDDYY10. -> YYYY-MM-DD
    # cell to mktg_cell (numeric)
    query_opt_in = f"""
    CREATE TABLE IF NOT EXISTS opt_in_py AS
    SELECT
        *,
        -- MMDDYY10. format for accept_date (assuming accept_dt is source)
        -- No direct MMDDYY10 format. Use date_format if accept_dt is date.
        -- If accept_dt is string 'MM/DD/YYYY', parse it first.
        -- For simplicity, let's assume accept_dt is already a date or usable string.
        -- accept_dt AS accept_date_formatted, -- Adjust formatting as needed
        date_format(TRY_CAST(accept_dt AS DATE), '%Y%m') AS accept_month, -- yymmn6. equivalent
        accept_dt AS accept_date, -- or parse/format if needed
        TRY_CAST(cell AS DOUBLE) AS mktg_cell
    FROM optin_optin_accts -- Assuming this is your Athena table
    WHERE CMPGN_ID IN ({campaign_id_list_sql});
    """
    run_athena_query(query_opt_in)
    
    # PROC SORT is handled by Athena's join strategy or subsequent ORDER BY if needed.

    # 4. Join Contact Log with Opt-in Data (cm_cld_master_v1)
    query_cm_cld_master_v1 = """
    CREATE TABLE IF NOT EXISTS cm_cld_master_v1_py AS
    SELECT
        a.*,
        d.CMPGN_ID AS d_CMPGN_ID, -- Disambiguate if names clash
        d.acct_id AS d_acct_id,
        d.mktg_cell AS d_mktg_cell,
        d.CMNCN_LOG_ID AS d_CMNCN_LOG_ID,
        d.accept_month AS d_accept_month,
        d.opt_acct AS d_opt_acct
        -- Select other columns from d as needed, prefixing with d_
    FROM cld_master_py a
    LEFT JOIN opt_in_py d
        ON a.Campaign_id = d.CMPGN_ID
        AND a.MARKETING_CELL = d.mktg_cell -- Assuming MARKETING_CELL is numeric like mktg_cell
        AND a.acct_id = d.acct_id;
    """
    run_athena_query(query_cm_cld_master_v1)

    # 5. Further Data Enrichment (cm_cld_master_v2)
    # SAS Formats: Use CASE WHEN. Example for ORIGIN, extend for others.
    # This part is complex and requires careful mapping of SAS logic to SQL.
    # For brevity, showing a few transformations.
    # Binning logic for MOB_range, fico_range, pd19_range needs full CASE WHEN.
    
    # Placeholder for SAS format mapping. In reality, use lookup tables or extensive CASE statements.
    cpc_origin_format = "CASE WHEN CPC = 'CODE1' THEN 'Origin Label 1' ELSE CAST(CPC AS VARCHAR) END" # Example
    cpc_platform_format = "CASE WHEN CPC = 'CODE_A' THEN 'Platform Label A' ELSE CAST(CPC AS VARCHAR) END"

    mob_range_logic = """
        CASE
            WHEN MOB IS NULL THEN 'I.Missing'
            WHEN MOB < 3 THEN 'A.<3'
            WHEN MOB < 6 THEN 'B.<6'
            WHEN MOB < 12 THEN 'C.<12'
            WHEN MOB < 18 THEN 'D.<18'
            WHEN MOB < 24 THEN 'E.<24'
            WHEN MOB < 36 THEN 'F.<36'
            WHEN MOB <= 60 THEN 'G.<=60'
            ELSE 'H.60+'
        END AS MOB_range
    """
    # Similarly define fico_range_logic and pd19_range_logic

    query_cm_cld_master_v2 = f"""
    CREATE TABLE IF NOT EXISTS cm_cld_master_v2_py AS
    SELECT
        *,
        {cpc_origin_format} AS ORIGIN,
        {cpc_platform_format} AS PLATFORM,
        -- ... PRODUCT, SEGMENT, PARTNER formats ...
        
        CASE WHEN Opt_in = 'N' THEN NULL ELSE CMNCN_LOG_ID END AS CMNCN_LOG_ID_updated,
        CASE WHEN Opt_in = 'N' THEN NULL ELSE d_CMPGN_ID END AS CMPGN_ID_updated, -- Assuming d_CMPGN_ID from opt_in
        CASE WHEN Opt_in = 'N' THEN NULL ELSE d_accept_month END AS accept_month_updated,
        CASE WHEN Opt_in = 'N' THEN NULL ELSE d_opt_acct END AS opt_acct_updated,
        CASE WHEN Opt_in = 'N' THEN NULL ELSE d_mktg_cell END AS mktg_cell_updated,

        CASE
            WHEN UPPER(TEST_CONTROL) = 'CONTROL' THEN 'NA'
            WHEN UPPER(TEST_CONTROL) = 'TEST' AND d_opt_acct = 1 THEN 'Y'
            WHEN UPPER(TEST_CONTROL) = 'TEST' AND (d_opt_acct <> 1 OR d_opt_acct IS NULL) THEN 'N'
            ELSE NULL -- Or some default
        END AS optin_derived,
        
        PD_19 * 100 AS pd19,
        {mob_range_logic}
        -- ... fico_range_logic ...
        -- ... pd19_range_logic (using (PD_19 * 100) AS base for pd19_range) ...
    FROM cm_cld_master_v1_py;
    -- Note: After this, you might want to drop original CMNCN_LOG_ID and use _updated versions, or rename.
    """
    run_athena_query(query_cm_cld_master_v2)

    # 6. Time Series Expansion (base_master)
    # Using UNNEST(SEQUENCE(...)) for the loop and date_add for INTNX equivalent.
    # Assumes 'Period' is in 'YYYYMM' string format.
    query_base_master = f"""
    CREATE TABLE IF NOT EXISTS base_master_py AS
    SELECT
        t1.*,
        s.t_value,
        date_format(
            date_add('month', s.t_value, parse_datetime(t1.Period || '01', 'yyyyMMdd')),
            '%Y%m'
        ) AS Period1
    FROM cm_cld_master_v2_py t1
    CROSS JOIN UNNEST(SEQUENCE(-3, 11)) AS s(t_value) -- Generates numbers from -3 to 11
    WHERE t1.Period <= '{per_cutoff}'; -- per_cutoff should be 'YYYYMM'
    """
    run_athena_query(query_base_master)

    # Min/Max period (informational, like %put)
    query_min_period = "SELECT MIN(period) as min_period FROM base_master_py;"
    exec_id = run_athena_query(query_min_period)
    df_min_period = get_query_results_as_df(exec_id)
    print(f"Min period in base_master_py: {df_min_period['min_period'].iloc[0]}")

    query_max_period_campaign = """
    SELECT MAX(period) as max_period FROM base_master_py WHERE campaign_id='BO27647';
    """
    exec_id = run_athena_query(query_max_period_campaign)
    df_max_period_campaign = get_query_results_as_df(exec_id)
    print(f"Max period for BO27647: {df_max_period_campaign['max_period'].iloc[0]}")


    # 7. Join with ASP Master Data (main1_base_master_v1_py)
    # Assuming aspmstr_asp_master is the Athena table for asp_master
    # And it has period1 formatted as YYYYMM
    query_main1_base_master_v1 = """
    CREATE TABLE IF NOT EXISTS main1_base_master_v1_py AS
    SELECT
        a.*,
        b.col_from_asp, b.another_col_from_asp -- Select specific columns from asp_master
        -- Avoid b.* if there are many columns or name clashes without aliases
    FROM base_master_py a
    LEFT JOIN aspmstr_asp_master b ON a.acct_id = b.acct_id AND a.Period1 = b.Period1;
    """
    run_athena_query(query_main1_base_master_v1)
    print("--- Phase 1 Completed ---")


def phase2_post_macro_processing():
    print("\n--- Phase 2: Post-Macro Processing ---")

    # 8. Data Enrichment - Financials (base_master_v2_py)
    # This requires translating all flag conversions and financial calculations to SQL
    # Example for flag conversion:
    # CASE WHEN ACCT_OPEN = 'Y' THEN 1 ELSE 0 END AS ACCT_OPEN_NUM
    # Financial calculations: e.g., sum(CHRGBOFF_AMT, RECOVRY_ACTL_TOT_AMT * -1) AS cr_loss_net_amt
    # This will be a very long query.
    
    # Define array elements for flag conversion
    flag_cols = ['ACCT_OPEN', 'ACCT_ACTV', 'ACTIVE_WITH_BAL', 'FLAG_PURCH', 
                 'ACTV_FLAG', 'REVOLVER', 'CO_ALL_IND', 'CO_MNTH_IND', 'FRAUD_IND']
    char_to_num_cols_sql = ",\n".join([f"CASE WHEN {col} = 'Y' THEN 1 ELSE 0 END AS {col}_NUM" for col in flag_cols])

    # Financial calculations (example for a few)
    financial_calcs_sql = """
        COALESCE(CHRGBOFF_AMT, 0) + COALESCE(RECOVRY_ACTL_TOT_AMT, 0) * -1 AS cr_loss_net_amt,
        CASE
            WHEN co_all_ind_NUM = 1 AND CHRGOFF_STATUS_RSN_CD NOT IN ('FRD') THEN (COALESCE(CHRGBOFF_AMT, 0) + COALESCE(RECOVRY_ACTL_TOT_AMT, 0) * -1)
            ELSE 0
        END AS NCL,
        (COALESCE(FIN_CHRG_GROSS_AMT,0) + COALESCE(FIN_CHRG_CHGOFF_RVRSL_TOT_AMT,0)) AS NET_INTERCHANGE,
        (COALESCE(RVFHR_BFG_SLS_TOT_AMT,0) + COALESCE(REVHRR_PURCH_TOT_AMT,0) + COALESCE(REVHHR_EXCISE_TAX_TOT_AMT,0)) AS Gross_Yield
        -- ... many more financial calculations from SAS code ...
        -- Rev_Bwd_MOD_new, Late_Fees, Annual_Fees, Cash_Ad_Fees, Other_Fees, Fraud_Losses
        -- nim_mod, Fee_Income, ncl_mod, rev_mod, PTP_mod, PBT_mod, Total_Risk, RISK_ADJUSTED_REVENUE_MOD
    """
    # Delinquency flags (example)
    delinquency_flags_sql = """
        CASE WHEN co_all_ind_NUM = 0 AND delq_ind >= 2 AND delq_ind <= 7 THEN 1 ELSE 0 END AS DQ_p_unit,
        CASE WHEN co_all_ind_NUM = 0 AND delq_ind >= 2 AND delq_ind <= 7 THEN current_balance ELSE 0 END AS DQ_p_dollar
        -- ... DQ3p, DQ4p, CO_unit, CO_amount ...
    """

    query_base_master_v2 = f"""
    CREATE TABLE IF NOT EXISTS base_master_v2_py AS
    SELECT
        *,
        {char_to_num_cols_sql},
        CASE WHEN ASSET_CLASS_CD <> 'Sold' THEN 'NON-BRONCO' ELSE 'BRONCO' END AS Bronco_Flag,
        {financial_calcs_sql},
        {delinquency_flags_sql}
    FROM main1_base_master_v1_py;
    """
    run_athena_query(query_base_master_v2)

    # 9. Prepare MCC Data (mcc_master_py)
    # Assuming aspmstr_mcc_master is the Athena table
    query_mcc_master = """
    CREATE TABLE IF NOT EXISTS mcc_master_py AS
    SELECT
        *,
        date_format(TRY_CAST(Period || '01' AS DATE), '%Y%m') AS Period1_mcc, -- Ensure Period1 matches format
        COALESCE(amt_GAFINC, 0) AS amt_GAFINC_clean,
        COALESCE(cnt_GAFINC, 0) AS cnt_GAFINC_clean,
        COALESCE(Points_GAFINC, 0) AS Points_GAFINC_clean,
        (COALESCE(net_trans_amt, 0) - COALESCE(amt_GAFINC, 0)) AS amt_NON_GAFINC,
        (COALESCE(net_trans_cnt, 0) - COALESCE(cnt_GAFINC, 0)) AS cnt_NON_GAFINC,
        (COALESCE(Points, 0) - COALESCE(Points_GAFINC, 0)) AS Points_NON_GAFINC
    FROM aspmstr_mcc_master; -- Assuming this is your Athena table
    """
    run_athena_query(query_mcc_master)

    # 10. Final Major Join (main1_base_master_v3_py)
    # Assuming fl_fulfillment and rds_RWA are Athena tables
    query_main1_base_master_v3 = """
    CREATE TABLE IF NOT EXISTS main1_base_master_v3_py AS
    SELECT
        a.*,
        b.col_from_fulfillment, -- select specific columns
        c.col_from_mcc,         -- select specific columns
        d.col_from_rwa          -- select specific columns
    FROM base_master_v2_py a
    LEFT JOIN fl_fulfillment b ON a.Campaign_id = b.Campaign_id AND a.acct_id = b.acct_id AND a.Period1 = b.Period1
    LEFT JOIN mcc_master_py c ON a.acct_id = c.acct_id AND a.Period1 = c.Period1_mcc -- Use Period1 from mcc_master
    LEFT JOIN rds_RWA d ON a.acct_id = d.acct_id AND a.Period1 = d.Period1;
    """
    run_athena_query(query_main1_base_master_v3)
    
    # Cleanup (Optional in Athena, tables persist until dropped)
    # run_athena_query("DROP TABLE IF EXISTS base_master_v2_py_intermediate;") # If you created one

    print("--- Phase 2 Completed ---")


def phase3_summarization_and_export(archive_list):
    print("\n--- Phase 3: Summarization and Export ---")
    
    archive_list_sql = ', '.join([f"'{item}'" for item in archive_list])


    # 11. Create Summary Table (main_tc_summ_py)
    # This will be a very long SELECT statement with many SUM() and COUNT()
    # Example structure:
    summary_select_list = """
        CAMPAIGN_ID, Campaign_Description, MARKETING_CELL, TEST_CONTROL, BFRCD AS offer, REGION, CPC,
        DM_ELIG, EM_ELIG, Optin_derived AS Optin, accept_month_updated AS accept_month, -- using updated/derived fields
        Bronco_Flag, Period1 AS Period, t_value AS t, 'ALL' AS cell_name, 'Test vs Control' AS View,
        
        COUNT(acct_id) AS Accounts,
        SUM(CAST(opt_acct_updated AS BIGINT)) AS opt_count, -- Assuming opt_acct is 0/1 or similar
        COUNT(DISTINCT CASE WHEN fulfilled_rewards > 0 THEN acct_id END) AS fulfill,
        SUM(fulfilled_rewards) AS fulfilled_rewards_sum, -- Renamed to avoid clash if fulfilled_rewards is a dimension
        SUM(fico) AS fico_sum,
        SUM(pd19) AS pd19_sum,
        SUM(ACCT_OPEN_NUM) AS ACCT_OPEN_NUM_sum
        -- ... many more SUM(...) clauses for all financial and behavioral metrics ...
        -- For category specific sums like amt_AIRLINES, ensure these columns exist in main1_base_master_v3_py
        -- (likely coming from mcc_master join)
        -- SUM(amt_AIRLINES) AS sum_amt_AIRLINES,
        -- COUNT(CASE WHEN cnt_AIRLINES > 0 THEN acct_id END) AS active_AIRLINES
    """
    summary_group_by_list = "1,2,3,4,5,6,7,8,9,10,11,12,13,14" # Corresponds to non-aggregated columns

    query_main_tc_summ = f"""
    CREATE TABLE IF NOT EXISTS main_tc_summ_py AS
    SELECT
        {summary_select_list}
    FROM main1_base_master_v3_py
    GROUP BY {summary_group_by_list};
    """
    run_athena_query(query_main_tc_summ)

    # 12. Optin-MatchPair Processing
    # Assuming mp_matchpair_master is the Athena table
    query_optin_base_v1 = """
    CREATE TABLE IF NOT EXISTS optin_base_v1_py AS
    SELECT a.*, b.* -- Be careful with b.*, might need aliasing
    FROM mp_matchpair_master a
    LEFT JOIN main1_base_master_v3_py b ON a.campaign_id = b.campaign_id AND a.opt_in_acct_id = b.acct_id;
    """
    run_athena_query(query_optin_base_v1)

    query_mp_base_v1 = """
    CREATE TABLE IF NOT EXISTS mp_base_v1_py AS
    SELECT a.*, b.* -- Be careful with b.*
    FROM mp_matchpair_master a
    LEFT JOIN main1_base_master_v3_py b ON a.campaign_id = b.campaign_id AND a.mp_acct_id = b.acct_id;
    """
    run_athena_query(query_mp_base_v1)

    # Concatenate and update TEST_CONTROL (UNION ALL in SQL)
    query_main_optin_mp_base_v1 = """
    CREATE TABLE IF NOT EXISTS main_optin_mp_base_v1_py AS
    SELECT
        *,
        CASE
            WHEN UPPER(TEST_CONTROL) = 'TEST' THEN 'Optin'
            WHEN UPPER(TEST_CONTROL) = 'CONTROL' THEN 'MP'
            ELSE TEST_CONTROL -- or NULL
        END AS TEST_CONTROL_final
    FROM optin_base_v1_py
    UNION ALL
    SELECT
        *,
        CASE
            WHEN UPPER(TEST_CONTROL) = 'TEST' THEN 'Optin'
            WHEN UPPER(TEST_CONTROL) = 'CONTROL' THEN 'MP'
            ELSE TEST_CONTROL -- or NULL
        END AS TEST_CONTROL_final
    FROM mp_base_v1_py;
    -- Note: This table will have TEST_CONTROL and TEST_CONTROL_final.
    -- Downstream use TEST_CONTROL_final as the new TEST_CONTROL.
    """
    run_athena_query(query_main_optin_mp_base_v1)
    
    # 13. Combine Summaries (main_tc_op_summ_py)
    # SAS code references main.optin_mp_summ which is NOT created.
    # For this Python script, I'll assume it meant to summarize main_optin_mp_base_v1_py
    # in a similar way to main_tc_summ_py, or that this step needs clarification.
    # For now, let's proceed as if main_optin_mp_summ_py would be created.
    # If main_optin_mp_summ is just main_optin_mp_base_v1 (unsummarized), then UNION ALL.
    print("WARNING: SAS code references main.optin_mp_summ which is not created. ")
    print("         Assuming a similar summary step for match-pair data would exist or this step needs review.")
    
    # If main_optin_mp_summ_py were to be created by summarizing main_optin_mp_bas
